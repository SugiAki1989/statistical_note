---
title: "指数・対数を用いた回帰モデル"
pagetitle: "指数・対数を用いた回帰モデル"
output:
  html_document:
    toc: TRUE
    toc_depth: 5
    toc_float: FALSE
    # number_sections: TRUE
    code_folding: "show"
    highlight: "kate"
    # theme: "flatly"
    css: ../style.css
    md_extensions: -ascii_identifiers
---

```{r SETUP, include = FALSE}
knitr::opts_chunk$set(echo       = TRUE,
                      message    = FALSE,
                      warning    = FALSE,
                      #out.width  = 1280,
                      #out.height = 720,
                      # fig.dim = c(8, 6),
                      fig.align  = "center",
                      dev        = "ragg_png")
```

<div class="update-right">
UPDATE: `r Sys.time()`
</div>

# はじめに
ここでは指数関数$y = \alpha \cdot e^{ \beta \cdot x }$の対数線型化について内容をまとめておく。ちょいと調べることがあって、そのまとめ。

## 指数関数の変化量
指数関数$y = \alpha \cdot e^{ \beta \cdot x }$は対数線型化すると$\ln y = ln  \alpha + \beta \cdot x$に変換できる。いわゆる「半対数モデル」に変換できる。左辺にだけ対数が使用されているのでセミログモデルともよばれる。半対数モデルは$\ln y$と$x$の直線的な関係をみており、$x$が1単位増えると、$\ln y$は$\beta$％だけ変化する。要するに直感的ではないのでわかりにくい・・・私が頭良くないので。この解釈を深ぼってみた。

## 対数差分
$\beta$の意味は$x$が1単位増えるときの$\ln y$の変化量 ということなので、下記のように差分を計算すると、$\beta$というのは変化率の近似値ということがわかる。

![](/Users/aki/Documents/statistical_note/note_regression07/memo.jpg)

## Rで実装
指数関数的なインドの人口データをサンプルとして利用する。5年毎の人口数を記録しているデータ。

```{r}
x <- seq(1950, 2010, length.out = 13)
y <- c(371857, 406374, 447844, 496400, 553874, 622097, 700059, 
       784491, 873785, 964486, 1053898, 1140043, 1224614)
df <- data.frame(x, y)
```

下記の指数関数でフィットできそうなので、この指数関数を対数化して`lm()`でパラメタを推定する。もちろん、指数関数を定義して`nls()`で計算してもよいが、`nls()`は色々面倒なので、ここではパス。

$$
\begin{eqnarray}
y = \alpha \cdot e^{ \beta \cdot x }
\end{eqnarray}
$$

```{r}
# y = a*exp(b*x) ⇔ ln(y) ~ ln(a) + b*x
fit <- lm(log(y) ~ x, data = df)
fit
```

$$
\begin{eqnarray}
\hat{ y } = -27.61171 + 0.02073 \cdot x 
\end{eqnarray}
$$

ということなので、-27.61171は$\ln a$のことなので、$a$を計算するために$e^{a}$とした上で、当初の指数関数で予測値を算出する。指数表記すると$10^{-12} * 1.0195$だと思うが、ここでは書き下しておく。

$$
\begin{eqnarray}
y = 0.000000000001019499 \cdot e^{ 0.02073 \cdot x }
\end{eqnarray}
$$

```{r}
# ln(a)=-27.61171 → a = exp(a)
a <- exp(-27.61171) 
# a [1] 1.019499e-12
b <- 0.02073
df$fitted <- a * exp(b * x)
```

回帰係数$b = 0.02073$の解釈については、

$$
\begin{eqnarray}
\frac{ y_{i} - y_{i-1} }{ y_{i-1} } = e^{b \cdot x} -1
\end{eqnarray}
$$

ということなので、今回のデータは5年ごとの人口数の推移なので、


$$
\begin{eqnarray}
\frac{ y_{i} - y_{i-1} }{ y_{i-1} } = e^{0.02073 \cdot 5}  -1 = 0.1107
\end{eqnarray}
$$

となり、5年あたりの変化率(人口成長率)は11.07%となり、これが1年であれば、

$$
\begin{eqnarray}
\frac{ y_{i} - y_{i-1} }{ y_{i-1} } = e^{0.02073 \cdot 1} - 1 =0.0212
\end{eqnarray}
$$

なので、1年あたりの変化率(人口成長率)は2.12%となる。可視化するとこうなる。

```{r}
library(ggplot2)

ggplot(df)+
  geom_point(aes(x, y)) +
  geom_line(aes(x, fitted)) + 
  theme_classic()
```


## nlsパッケージの代わりのminpack.lmパッケージ
こんな感じでコネコネ対数化しなくても、nlsパッケージで指数関数をそのまま渡して、フィッティングしても問題ないと思う・・・が、nlsパッケージはなにかとエラーが出やすいので、私のようなトーシロには扱いにくい。そこでminpack.lmパッケージを使う。minpack.lmパッケージでは、非線形関数に対する最小値問題の解法として、Levenberg-Marquerdt法でパラメタを計算する。Levenberg-Marquerdt法は最初は再急降下法、解に近づいたらガウス・ニュートン法に切り替えて、目的関数を繰り返し計算することで小さくしていく方法。なので、`nls.lm()`では、目的関数を最小化するように引数を渡すことになる。

```{r}
library(minpack.lm)
x <- seq(1950, 2010, length.out = 13)
y <- c(371857, 406374, 447844, 496400, 553874, 622097, 700059, 
       784491, 873785, 964486, 1053898, 1140043, 1224614)
df <- data.frame(x, y)

# 初期パラメタ設定のカンニング
res_lm <- lm(formula = log(y) ~ x, data = df) 
init_a <- exp(res_lm$coefficients[1]) 
init_b <- res_lm$coefficients[2] 

x <- df$x 
obs <- df$y
pred  <- function(p, xx) p$a * exp(p$b * xx)  
resid <- function(p, observed, xx) observed - pred(p, xx)
init_par <- list(a = init_a, b = init_b) 

fit <- nls.lm(
  xx = x,
  observed = obs,
  fn = resid,
  par = init_par,
  control = nls.lm.control(maxiter = 1024, nprint = 1)
)

summary(fit)
```


```{r}
nls_a <- fit$par$a
nls_b <- fit$par$b
df$nls_fitted <- pred(p = list(a = nls_a, b = nls_b), xx = x)

library(ggplot2)
ggplot(df) +
  geom_point(aes(x, y)) +
  geom_line(aes(x, nls_fitted)) +
  theme_classic()
```

## おまけ1

30%が39%になったとき、39/30=1.3なので「9%」の増加ではなく「3%」の増加。これを「9ポイント」の増加と表現する。

## おまけ2

両対数モデル対数線型化すると$\ln y = ln  \alpha + \beta \cdot ln  x$は「両対数モデル」。両対数モデルは$x$が1％単位増えると、$\ln y$は$\beta$％だけ変化する。

```{r}
library(tidyverse)
library(scales)
df <- structure(list(x = c(37.02, 39.51, 47.73, 48.28, 51.27, 56.39, 
59.64, 59.71, 60.61, 61.84, 62.14, 62.84, 66.06, 68.67, 69.09, 
69.18, 70.08, 71.96, 72.86, 73.48, 74.13, 74.3, 74.67, 75.79, 
75.8, 76.34, 76.5, 77.51, 77.61, 79.91, 80.38, 80.39, 80.43, 
80.86, 82.51, 86.72, 87.08, 87.36, 89.47, 90.57, 91.97, 92.01, 
92.13, 92.48, 94.92, 97.7, 100.76, 101.71, 102.57, 103.2, 104.17, 
107.82, 108.04, 109.72, 109.93, 110.8, 111.77, 111.95, 112.29, 
113.68, 113.93, 114.16, 115.11, 115.45, 116.13, 116.32, 116.5, 
116.93, 119.16, 119.71, 120.03, 120.69, 121.02, 121.67, 122.39, 
122.96, 123.59, 124.63, 125.2, 126.13, 128.2, 129.28, 129.71, 
130.96, 131.35, 132.23, 132.63, 132.66, 134.41, 135.29, 135.3, 
136.01, 136.38, 136.93, 137.24, 138.18, 138.32, 140.77, 144.03, 
144.96, 145.15, 149.93, 151.32, 151.67, 152.52, 157.65, 160.26, 
160.52, 161.44, 161.58, 161.96, 162.31, 163.3, 164.91, 166.4, 
166.43, 166.86, 168.35, 170.67, 170.89, 174.2, 174.6, 174.73, 
174.89, 174.93, 176.41, 176.43, 176.53, 177.04, 178.25, 180.31, 
181.7, 183.17, 183.3, 183.32, 184.26, 184.35, 185.07, 186.58, 
189, 189.17, 189.26, 190.96, 191.45, 192.03, 192.04, 193.1, 193.29, 
194.84, 196.03, 196.11, 197.46, 197.75, 198.5, 200.14, 200.21, 
201, 202.36, 203.71, 204.43, 205.18, 208.11, 208.93, 209.25, 
210.83, 211.69, 212.1, 212.18, 213.36, 214.17, 217.43, 219.82, 
220.69, 221.61, 222.18, 224.6, 226.2, 227.49, 227.89, 228.36, 
229.47, 230.13, 231.9, 235.72, 236.5, 244.46, 244.51, 244.81, 
246.81, 247.07, 249.9, 251.02, 253.3, 254.73, 254.86, 255.57, 
255.75, 256.87, 257.86, 258.54), y = c(2222.32, 2202.38, 2590.29, 
2281.37, 2370.36, 2348.79, 2463.7, 2511.71, 2385.07, 2339.25, 
2555.6, 2547.69, 2438.93, 2546.07, 2785.52, 2665.16, 2494.81, 
2689.2, 2603.23, 2410.28, 2467.54, 2420.38, 2549.48, 2737.52, 
2539.91, 2349.46, 2803.46, 2636.5, 2528.86, 2617.78, 2788.7, 
2564.32, 2825.09, 2623.81, 2637.92, 2727.83, 2910.96, 2753.95, 
2724.13, 3048.19, 2674.23, 2685.19, 2709.63, 2653.29, 2683.19, 
2819.6, 2908.35, 2773.82, 2844.26, 2645.23, 2873.45, 2685.92, 
2927.15, 2671.7, 2585.38, 2594.85, 2983.36, 2992.01, 3179.27, 
2894.2, 2807.12, 3058.08, 2836.37, 2850.06, 2909.13, 3015.87, 
2888.5, 2873.56, 2975.6, 2883.41, 2852.07, 3064.73, 2835.07, 
2859.48, 2977.81, 2850.68, 2948.12, 2847.23, 2892.27, 2828.08, 
2897.52, 2977.36, 2914.79, 2856.47, 2990.32, 2966.5, 3111.06, 
2606.25, 2781.62, 3001.49, 3145.2, 2821.24, 2742.66, 3097.45, 
3000.8, 3115.1, 3058.95, 2796.17, 2927.21, 3153.79, 3033.11, 
3192.74, 2916.45, 3104.92, 2927.72, 3022.24, 3004.02, 3137.29, 
3096.55, 2965.18, 3157.04, 3285.46, 3068.87, 3104.39, 3199.4, 
3114.7, 3214.57, 2849.37, 3363.34, 2847.73, 3074.9, 3018.01, 
3095.36, 3060.31, 3103.62, 3131.26, 2949.09, 3278.77, 2969.07, 
3233.33, 3073.76, 3126.97, 3236.47, 3355.7, 3089.88, 3085.4, 
3309.19, 3149.66, 3278.12, 3084.82, 3315.15, 3166.87, 3038.28, 
3114.49, 3151.16, 3242.14, 3211.64, 3269.05, 3262.71, 3070.54, 
3085.48, 3289.32, 3260.07, 3170.33, 3214.82, 3314.96, 3196.11, 
3147.6, 3284.88, 3132.4, 3156.46, 3165.42, 3194.68, 3480.29, 
3310.13, 3274.93, 3190.17, 3362.12, 3334.05, 2993.88, 3315.54, 
3259.08, 3351.82, 3544.53, 3422.43, 3394.66, 3352.86, 3200.08, 
3205.98, 3269.16, 3280.44, 3239.95, 3355.97, 3463.38, 3249.61, 
3405.55, 3410.15, 3322.29, 3319.95, 3466.56, 3244.31, 3126.41, 
3348.52, 3367.87, 3206.18, 3475.06, 3296.34, 3499.94, 3411.42, 
3273.21)), class = "data.frame", row.names = c(NA, -200L))
```

```{r}
fit <- lm(log(y) ~ log(x), data = df)
df$p <- exp(fit$fitted.values)
fit
```

係数が`0.2139`なので、xが1%増加するとyが0.2139％増加するという関係になっている。可視化すると効果が逓減していく様子が見れる。

```{r}
ggplot() +
  geom_point(data = df, aes(x, y), col = 'gray') +
  geom_line(data = df, aes(x, p), col = 'royalblue') +
  scale_y_continuous(label = comma, breaks = seq(2000, 3500, 100)) +
  scale_x_continuous(breaks = seq(00, 300, 10)) +
  theme_bw()
```

このモデルを使って予測値を計算すると、`x=100`だと`y=2771.068`、`x=200`だと`y=3214.011`となる。

```{r}
exp(predict(fit, newdata = data.frame(x = 100)))
```

```{r}
exp(predict(fit, newdata = data.frame(x = 200)))
```

下記はメモ。`x`が1%増加するとyは`0.2139`%増加するので、どの時点1％増加させても弾力性は常に約0.21%となる。

```{r}
f <- function(a, b) {
  b1 <- fit$coefficients[[1]]
  b2 <- fit$coefficients[[2]]
  a <- exp(b1 + b2 * log(a))
  b <- exp(b1 + b2 * log(b))
  diff <- b - a
  e <- (diff / a) * 100
  
  return(list(
    pre = a,
    post = b,
    difference = diff,
    elasticity = e
  ))
}
```

```{r}
# xが1%増加するとyは0.2106%増加するので、どの時点でも弾力性elasticityは常に約0.21%増加する
f(100, 100 * 1.01) # 101
```

```{r}
f(150, 150 * 1.01) # 151.5
```

```{r}
f(200, 200 * 1.01) # 202
```

```{r}
f(400, 400 * 1.01) # 404
```

```{r}
f(1000, 1000 * 1.01) # 1010
```

可視化している通り逓減しているので、実スケールで各時点で1づつ増やすと、増加量はどの時点でも1で同じだが、`diff`がどんどん小さくなる様子が見れる。1%ではなく1なので`elasticity`は21％ではない。

```{r}
f(100, 101)
```

```{r}
f(150, 151)
```

```{r}
f(200, 201)
```

```{r}
f(400, 401)
```

```{r}
f(1000, 1001)
```

`dput(df)`という、オブジェクトを再作成するための関数があるのか。しらなんだ。

```{r}
dput(df)
```
## 参考文献
- [44の例題で学ぶ計量経済学](https://www.ohmsha.co.jp/book/9784274069314/)
